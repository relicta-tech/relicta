# Monorepo Release Configuration
#
# Use case: Monorepo with multiple packages released independently
# Features: Package-scoped versioning, independent changelog per package
#
# Setup:
# 1. Copy to release.config.yaml in each package directory (e.g., packages/api/, packages/web/)
# 2. Set GITHUB_TOKEN and NPM_TOKEN environment variables
# 3. Run from package directory: cd packages/api && relicta plan && relicta publish
#
# Directory structure:
# monorepo/
# ├── packages/
# │   ├── api/
# │   │   ├── release.config.yaml
# │   │   ├── package.json
# │   │   └── CHANGELOG.md
# │   └── web/
# │       ├── release.config.yaml
# │       ├── package.json
# │       └── CHANGELOG.md
# └── README.md

versioning:
  strategy: conventional
  # Use package-specific tag prefix
  tag_prefix: "@scope/package-name@"  # e.g., @myorg/api@1.0.0
  git_tag: true
  git_push: true
  update_files:
    - package.json
    - package-lock.json

changelog:
  enabled: true
  file: CHANGELOG.md
  format: conventional
  # Package-specific repository URL
  repository_url: https://github.com/your-org/monorepo/tree/main/packages/api

ai:
  enabled: true
  provider: openai
  model: gpt-4o-mini
  tone: professional
  audience: developers

plugins:
  - name: npm
    enabled: true
    config:
      registry: https://registry.npmjs.org
      access: public
      tag: latest
      package_dir: .

  - name: github
    enabled: true
    config:
      draft: false
      prerelease: false
      # Create package-scoped release
      release_name_template: "{{.PackageName}} v{{.Version}}"
      body_template: |
        ## {{.PackageName}} v{{.Version}}

        {{.ReleaseNotes}}

        **Package:** `packages/{{.PackageName}}`

  - name: slack
    enabled: true
    config:
      channel: "#releases"
      username: "Monorepo Release Bot"
      icon_emoji: ":package:"

workflow:
  require_approval: true
  allowed_branches:
    - main
  # Only analyze commits that affect this package
  commit_filter:
    paths:
      - "packages/api/**"

# Tips for monorepo releases:
# 1. Use package-specific tags: @scope/package@version
# 2. Filter commits by package path
# 3. Maintain separate changelogs per package
# 4. Use workspaces in package.json for dependency management
# 5. Consider tools like Turborepo or Nx for build orchestration
